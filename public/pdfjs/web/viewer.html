<!DOCTYPE html>
<html dir="ltr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="google" content="notranslate">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>PDF Viewer</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.js"></script>

  <style>
    body { margin:0; padding:0; overflow:hidden; font-family:sans-serif; }
    #outerContainer { width:100%; height:100vh; position:absolute; display:flex; flex-direction:column; }
    #toolbarContainer { background:#f0f0f0; padding:10px; display:flex; gap:20px; border-bottom:1px solid #ccc; flex-wrap:wrap; }
    #mainContainer {
      flex:1;
      overflow:auto;
      background:#525659;
      padding:10px;
      position: relative;
    }
    #mainContainer.can-pan { cursor: grab; }
    #mainContainer.is-panning { cursor: grabbing !important; }
    #viewerWrapper {
      /* Quan trọng: không dùng flex-center khi nội dung lớn hơn viewport,
         nếu không mép trái sẽ bị "trôi" ra ngoài và không thể scroll tới. */
      width: max-content;
      margin: 0 auto;
    }
    #viewer { background:transparent; margin: 0 auto; }
    .page { background:white; position:relative; margin:0 auto 15px auto; box-shadow:0 2px 8px rgba(0,0,0,0.3); }

    #toolbarLeft,#toolbarMiddle,#toolbarRight { display:flex; gap:10px; align-items:center; }
    .toolbarButton, select, input { padding:5px 10px; border:1px solid #ccc; border-radius:3px; cursor:pointer; font-size:14px; background:white; }
    .toolbarButton:hover { background:#e0e0e0; }
    input[type="number"] { width: 60px; }

    .textLayer {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      opacity: 0.2;
      line-height: 1.0;
      z-index: 2;
    }

    .textLayer > span {
      color: transparent;
      position: absolute;
      white-space: pre;
      cursor: text;
      transform-origin: 0% 0%;
    }

    .textLayer ::selection {
      background: rgba(0,120,255,0.35);
    }

    .vocab-highlight {
      z-index: 10;
      position: absolute;
      background-color: rgba(255,235,59,0.4);
      border: 1px solid rgba(251,192,45,0.6);
      cursor: pointer;
      transition: all 0.2s;
      pointer-events: auto;
    }

    .vocab-highlight:hover {
      background-color: rgba(255,213,79,0.5);
      border: 1px solid rgba(251,192,45,0.9);
      box-shadow: 0 0 8px rgba(251,192,45,0.5);
    }

    .vocab-tooltip {
      position: fixed;
      z-index: 9999;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      font-size: 13px;
      max-width: 250px;
      white-space: normal;
      word-wrap: break-word;
    }

    .tooltip-word {
      font-weight: bold;
      margin-bottom: 4px;
      color: #333;
    }

    .tooltip-meaning {
      color: #555;
      margin-bottom: 3px;
    }

    .tooltip-pronunciation {
      color: #888;
      font-size: 12px;
      font-style: italic;
    }

    #pageIndicator {
      position: fixed;
      right: 12px;
      bottom: 12px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 14px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 10000;
      pointer-events: none;
      font-family: monospace;
    }

    #zoomIndicator {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 18px;
      z-index: 10001;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      font-family: monospace;
    }

    #zoomIndicator.show {
      opacity: 1;
    }

    .page-placeholder {
      background: #e0e0e0;
      position: relative;
      margin-bottom: 15px;
    }
  </style>
</head>

<body>
  <div id="outerContainer">
    <div id="toolbarContainer">
      <div id="toolbarLeft">
        <button id="previous" class="toolbarButton" title="Previous Page">◀</button>
        <input id="pageNumber" type="number" title="Page" value="1" min="1" />
        <span id="pageCount">/ 0</span>
        <button id="next" class="toolbarButton" title="Next Page">▶</button>
      </div>

      <div id="toolbarRight">
        <select id="scaleSelect" title="Zoom">
          <option value="page-width" selected>Fit Width</option>
          <option value="50">50%</option>
          <option value="75">75%</option>
          <option value="100">100%</option>
          <option value="125">125%</option>
          <option value="150">150%</option>
          <option value="200">200%</option>
        </select>
      </div>
    </div>

    <div id="mainContainer">
      <div id="viewerWrapper">
        <div id="viewer"></div>
      </div>
    </div>
  </div>

  <div id="pageIndicator">1 / 1</div>
  <div id="zoomIndicator">100%</div>

  <script>
    let pdfjsLib = null;
    let pdfDoc = null;
    let pageNum = 1;
    let zoomMode = "page-width";
    let fixedScale = 1.5;
    let currentHighlights = [];
    let pdfIdFromParent = null;

    // Cache plain text per page for context extraction
    const pagePlainTextByNumber = new Map();

    let renderedPages = new Set();
    let pageHeights = new Map();
    let estimatedPageHeight = 800;

    let selectionTimeout = null;
    let pageUpdateTimer = null;
    let isNavigating = false;

    let pageObserver = null;
    let visiblePages = new Map();

    let zoomIndicatorTimeout = null;
    const MIN_SCALE = 0.25;
    const MAX_SCALE = 5.0;

    let viewerGen = 0;
    const renderingPages = new Map();

    function bumpViewerGen() {
      viewerGen += 1;
      renderingPages.clear();
    }

    function waitForPdfJs() {
      if (window.pdfjsLib) {
        pdfjsLib = window.pdfjsLib;
        pdfjsLib.GlobalWorkerOptions.workerSrc =
          "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
        return Promise.resolve();
      }
      return new Promise(resolve => setTimeout(() => waitForPdfJs().then(resolve), 100));
    }

    function updatePageIndicator() {
      const indicator = document.getElementById('pageIndicator');
      if (indicator && pdfDoc) {
        indicator.textContent = `${pageNum} / ${pdfDoc.numPages}`;
      }
    }

    function showZoomIndicator(scale) {
      const indicator = document.getElementById('zoomIndicator');
      const percentage = Math.round(scale * 100);
      indicator.textContent = `${percentage}%`;
      indicator.classList.add('show');

      if (zoomIndicatorTimeout) clearTimeout(zoomIndicatorTimeout);
      zoomIndicatorTimeout = setTimeout(() => {
        indicator.classList.remove('show');
      }, 800);
    }

    function updateScaleSelect(scale) {
      const select = document.getElementById('scaleSelect');
      if (!select) return;

      if (zoomMode === 'page-width') {
        select.value = 'page-width';
        return;
      }

      const percentage = Math.round(scale * 100);
      const numericOptions = Array.from(select.options)
        .map(opt => parseInt(opt.value, 10))
        .filter(n => !Number.isNaN(n));

      if (numericOptions.length === 0) return;

      let best = numericOptions[0];
      let bestDiff = Math.abs(best - percentage);
      for (const n of numericOptions) {
        const diff = Math.abs(n - percentage);
        if (diff < bestDiff) {
          best = n;
          bestDiff = diff;
        }
      }

      select.value = String(best);
    }

    function setCurrentPage(newPage, skipNotify) {
      if (!pdfDoc) return;

      const clamped = Math.max(1, Math.min(newPage, pdfDoc.numPages));
      if (clamped === pageNum) {
        updatePageIndicator();
        return;
      }

      pageNum = clamped;

      const input = document.getElementById('pageNumber');
      if (input) input.value = pageNum;

      updatePageIndicator();

      if (!skipNotify) {
        if (pdfIdFromParent) {
          try {
            localStorage.setItem('pdf_last_page_' + pdfIdFromParent, String(pageNum));
          } catch (e) {
            console.error('Failed to save page:', e);
          }
        }

        if (pageUpdateTimer) clearTimeout(pageUpdateTimer);

        pageUpdateTimer = setTimeout(() => {
          window.parent.postMessage({
            type: 'PDF_CURRENT_PAGE',
            pageNumber: pageNum,
            pdfId: pdfIdFromParent
          }, '*');
        }, 200);
      }
    }

    function setupPageObserver() {
      if (pageObserver) {
        pageObserver.disconnect();
      }

      visiblePages.clear();

      const options = {
        root: document.getElementById('mainContainer'),
        rootMargin: '0px',
        threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
      };

      pageObserver = new IntersectionObserver((entries) => {
        if (isNavigating) return;

        entries.forEach(entry => {
          const entryPageNum = parseInt(entry.target.getAttribute('data-page-number'), 10);
          if (isNaN(entryPageNum)) return;

          if (entry.isIntersecting && entry.intersectionRatio > 0) {
            visiblePages.set(entryPageNum, entry.intersectionRatio);
          } else {
            visiblePages.delete(entryPageNum);
          }
        });

        if (visiblePages.size > 0) {
          let bestPage = null;
          let bestRatio = 0;

          visiblePages.forEach((ratio, page) => {
            if (ratio > bestRatio) {
              bestRatio = ratio;
              bestPage = page;
            }
          });

          if (bestPage !== null && bestPage !== pageNum) {
            setCurrentPage(bestPage);
          }
        }
      }, options);
    }

    function observePage(pageDiv) {
      if (pageObserver && pageDiv) {
        pageObserver.observe(pageDiv);
      }
    }

    function getVisiblePageRange() {
      if (!pdfDoc) return { first: 1, last: 1 };

      const container = document.getElementById('mainContainer');
      if (!container) return { first: pageNum, last: pageNum };

      const scrollTop = container.scrollTop;
      const viewportHeight = container.clientHeight;

      let accumulatedHeight = 0;
      let firstVisible = 1;
      let lastVisible = 1;
      let foundFirst = false;

      for (let i = 1; i <= pdfDoc.numPages; i++) {
        const pageHeight = pageHeights.get(i) || estimatedPageHeight;

        if (!foundFirst && accumulatedHeight + pageHeight >= scrollTop) {
          firstVisible = i;
          foundFirst = true;
        }

        if (accumulatedHeight <= scrollTop + viewportHeight) {
          lastVisible = i;
        }

        accumulatedHeight += pageHeight + 15;

        if (accumulatedHeight > scrollTop + viewportHeight) break;
      }

      return {
        first: Math.max(1, firstVisible),
        last: Math.min(pdfDoc.numPages, lastVisible)
      };
    }

    function computeScale(page) {
      const base = page.getViewport({ scale: 1 });
      const container = document.getElementById("mainContainer");
      const cw = Math.max(100, (container ? container.clientWidth : window.innerWidth) - 24);

      if (zoomMode === "page-width") return cw / base.width;
      return fixedScale;
    }

    async function tryRenderTextLayer(page, viewport, textLayerDiv) {
      try {
        const textContent = await page.getTextContent();

        if (pdfjsLib && typeof pdfjsLib.renderTextLayer === "function") {
          const task = pdfjsLib.renderTextLayer({
            textContentSource: textContent,
            container: textLayerDiv,
            viewport,
            textDivs: []
          });
          await (task.promise || task);
          return true;
        }

        if (window.pdfjsViewer && window.pdfjsViewer.TextLayerBuilder) {
          const eventBus = new window.pdfjsViewer.EventBus();
          const tlb = new window.pdfjsViewer.TextLayerBuilder({
            textLayerDiv,
            pageIndex: page.pageNumber - 1,
            viewport,
            eventBus,
          });
          tlb.setTextContent(textContent);
          await tlb.render();
          return true;
        }

        return false;
      } catch (e) {
        console.warn("Text layer render failed:", e);
        return false;
      }
    }

    function buildPlainTextFromTextContent(textContent) {
      try {
        const items = (textContent && Array.isArray(textContent.items)) ? textContent.items : [];
        const parts = [];
        for (const it of items) {
          const s = (it && typeof it.str === 'string') ? it.str : '';
          if (!s) continue;
          parts.push(s);
        }
        // Normalize whitespace for stable searching
        return parts.join(' ').replace(/\s+/g, ' ').trim();
      } catch (e) {
        return '';
      }
    }

    function extractContextSentence(plainText, selectedText) {
      const p = (plainText || '').toLowerCase().replace(/\s+/g, ' ').trim();
      const t = (selectedText || '').toLowerCase().replace(/\s+/g, ' ').trim();
      if (!p || !t) return '';

      const idx = p.indexOf(t);
      if (idx < 0) return '';

      // sentence boundaries: . ? ! or newline
      const leftBound = Math.max(
        p.lastIndexOf('.', idx - 1),
        p.lastIndexOf('?', idx - 1),
        p.lastIndexOf('!', idx - 1),
        p.lastIndexOf('\n', idx - 1)
      );
      let start = leftBound >= 0 ? leftBound + 1 : Math.max(0, idx - 90);

      const after = idx + t.length;
      const candidates = [
        p.indexOf('.', after),
        p.indexOf('?', after),
        p.indexOf('!', after),
        p.indexOf('\n', after)
      ].filter(n => n >= 0);
      let end = candidates.length > 0 ? Math.min(...candidates) + 1 : Math.min(p.length, after + 90);

      let sentence = p.slice(start, end).trim();
      // Clamp very long outputs to a compact window
      if (sentence.length > 220) {
        const winStart = Math.max(0, idx - 90);
        const winEnd = Math.min(p.length, after + 90);
        sentence = p.slice(winStart, winEnd).trim();
      }
      return sentence;
    }

    function findFirstTextDescendant(node) {
      try {
        if (!node) return null;
        if (node.nodeType === Node.TEXT_NODE) return node;
        const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null);
        return walker.nextNode();
      } catch (e) {
        return null;
      }
    }

    function buildTextFromTextLayerAndGetIndex(textLayerEl, selection) {
      try {
        if (!textLayerEl || !selection) return null;

        // Use focus (where the mouseup ended). This maps better when selecting across multiple words.
        const focusNode = findFirstTextDescendant(selection.focusNode) || findFirstTextDescendant(selection.anchorNode);
        const focusOffsetRaw = typeof selection.focusOffset === 'number' ? selection.focusOffset : 0;

        let out = '';
        let outIndexAtFocus = -1;

        const walker = document.createTreeWalker(textLayerEl, NodeFilter.SHOW_TEXT, null);
        let prevEndedWithSpace = true;
        let n;
        while ((n = walker.nextNode())) {
          const nodeText = n.nodeValue || '';
          if (!nodeText) continue;

          const startsWithSpace = /^\s/.test(nodeText);
          const needsSpace = out.length > 0 && !prevEndedWithSpace && !startsWithSpace;
          const prefix = needsSpace ? ' ' : '';

          if (focusNode && n === focusNode && outIndexAtFocus < 0) {
            const clampedOffset = Math.max(0, Math.min(focusOffsetRaw, nodeText.length));
            outIndexAtFocus = out.length + prefix.length + clampedOffset;
          }

          out += prefix + nodeText;
          prevEndedWithSpace = /\s$/.test(nodeText);
        }

        out = out.replace(/\s+/g, ' ').trim();
        if (!out) return null;

        // If trimming shifted the index slightly, clamp it.
        if (outIndexAtFocus >= out.length) outIndexAtFocus = out.length - 1;
        if (outIndexAtFocus < 0) outIndexAtFocus = Math.floor(out.length / 2);

        return { text: out, index: outIndexAtFocus };
      } catch (e) {
        return null;
      }
    }

    function extractContextSentenceAtIndex(fullText, index) {
      const s = String(fullText || '');
      if (!s) return '';
      const lower = s.toLowerCase();
      const idx = Math.max(0, Math.min(Number.isFinite(index) ? index : 0, lower.length - 1));

      // sentence boundaries: . ? ! or newline
      const leftBound = Math.max(
        lower.lastIndexOf('.', idx),
        lower.lastIndexOf('?', idx),
        lower.lastIndexOf('!', idx),
        lower.lastIndexOf('\n', idx)
      );
      let start = leftBound >= 0 ? leftBound + 1 : Math.max(0, idx - 90);

      const candidates = [
        lower.indexOf('.', idx + 1),
        lower.indexOf('?', idx + 1),
        lower.indexOf('!', idx + 1),
        lower.indexOf('\n', idx + 1)
      ].filter(n => n >= 0);
      let end = candidates.length > 0 ? Math.min(...candidates) + 1 : Math.min(lower.length, idx + 90);

      let sentence = s.slice(start, end).trim();
      // Clamp very long outputs to a compact window
      if (sentence.length > 220) {
        const winStart = Math.max(0, idx - 90);
        const winEnd = Math.min(lower.length, idx + 90);
        sentence = s.slice(winStart, winEnd).trim();
      }
      return sentence;
    }

    function renderHighlightsForPage(pageDiv, pageNumber) {
      const rect = pageDiv.getBoundingClientRect();
      if (rect.bottom < -100 || rect.top > window.innerHeight + 100) {
        return;
      }

      pageDiv.querySelectorAll(".vocab-highlight").forEach(el => el.remove());

      const list = currentHighlights.filter(h => h.pageNumber === pageNumber);

      list.forEach(hl => {
        (hl.rects || []).forEach(r => {
          const d = document.createElement("div");
          d.className = "vocab-highlight";
          d.dataset.wordKey = hl.wordKey || "";
          d.dataset.word = hl.text || "";
          d.dataset.meaning = hl.meaning || "";
          d.dataset.pronunciation = hl.pronunciation || "";

          d.style.left = (r.xPct * 100) + "%";
          d.style.top = (r.yPct * 100) + "%";
          d.style.width = (r.wPct * 100) + "%";
          d.style.height = (r.hPct * 100) + "%";

          d.addEventListener("mouseenter", function () {
            document.querySelectorAll(".vocab-tooltip").forEach(el => el.remove());

            const word = this.dataset.word || this.dataset.wordKey || "";
            const meaning = this.dataset.meaning || "";
            const pronunciation = this.dataset.pronunciation || "";

            const tooltip = document.createElement("div");
            tooltip.className = "vocab-tooltip";
            tooltip.innerHTML = `
              ${word ? `<div class="tooltip-word">${word}</div>` : ""}
              ${meaning ? `<div class="tooltip-meaning">${meaning}</div>` : `<div class="tooltip-meaning">(chưa có nghĩa)</div>`}
              ${pronunciation ? `<div class="tooltip-pronunciation">${pronunciation}</div>` : ""}
            `;

            document.body.appendChild(tooltip);

            const targetRect = this.getBoundingClientRect();
            const tipRect = tooltip.getBoundingClientRect();

            let left = targetRect.left + targetRect.width / 2 - tipRect.width / 2;
            let top = targetRect.top - tipRect.height - 8;

            if (top < 6) {
              top = targetRect.bottom + 8;
            }

            left = Math.max(6, Math.min(left, window.innerWidth - tipRect.width - 6));

            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;

            this._tooltip = tooltip;
          });

          d.addEventListener("mouseleave", function () {
            if (this._tooltip) {
              this._tooltip.remove();
              this._tooltip = null;
            }
          });

          pageDiv.appendChild(d);
        });
      });
    }

    function clearViewer() {
      document.getElementById("viewer").innerHTML = "";
      renderedPages.clear();
      pageHeights.clear();
      visiblePages.clear();
      pagePlainTextByNumber.clear();
    }

    function centerView() {
      const container = document.getElementById('mainContainer');
      // Căn giữa dựa trên chính scrollWidth của container để ổn định với mọi layout.
      const maxScrollX = Math.max(0, container.scrollWidth - container.clientWidth);
      container.scrollLeft = Math.max(0, Math.min(maxScrollX, maxScrollX / 2));
    }

    async function renderPage(num, pageDiv) {
      if (!pdfDoc || num < 1 || num > pdfDoc.numPages) return;
      if (renderedPages.has(num)) return;

      const genAtStart = viewerGen;
      if (renderingPages.has(num)) return renderingPages.get(num);

      const p = (async () => {
        try {
          const page = await pdfDoc.getPage(num);
          if (viewerGen !== genAtStart) return;

          const scale = computeScale(page);
          const viewport = page.getViewport({ scale });

          pageDiv.style.width = viewport.width + "px";
          pageDiv.style.height = viewport.height + "px";
          pageDiv.className = "page";
          pageDiv.setAttribute("data-page-number", num);
          pageDiv.setAttribute('data-rendered', 'true');
          pageDiv.style.setProperty('--scale-factor', scale);

          pageHeights.set(num, viewport.height);

          const canvas = document.createElement("canvas");
          canvas.style.position = "absolute";
          canvas.style.left = "0";
          canvas.style.top = "0";
          canvas.style.zIndex = "1";
          canvas.style.width = viewport.width + "px";
          canvas.style.height = viewport.height + "px";

          const ctx = canvas.getContext("2d");

          const dpr = window.devicePixelRatio || 1;
          const outputScale = Math.min(dpr, 2);
          canvas.width = Math.floor(viewport.width * outputScale);
          canvas.height = Math.floor(viewport.height * outputScale);

          const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;

          const textLayerDiv = document.createElement("div");
          textLayerDiv.className = "textLayer";
          textLayerDiv.style.width = viewport.width + "px";
          textLayerDiv.style.height = viewport.height + "px";

          pageDiv.replaceChildren(canvas, textLayerDiv);

          const textContentPromise = page.getTextContent();

          const renderTask = page.render({ canvasContext: ctx, viewport, transform });
          await renderTask.promise;
          if (viewerGen !== genAtStart) return;

          const textContent = await textContentPromise;
          if (viewerGen !== genAtStart) return;

          // Cache plain text for context extraction
          try {
            const plain = buildPlainTextFromTextContent(textContent);
            if (plain) pagePlainTextByNumber.set(num, plain);
          } catch (e) {}

          // Render selectable text layer
          try {
            // Reuse textContent we already fetched (avoid double fetch)
            if (pdfjsLib && typeof pdfjsLib.renderTextLayer === "function") {
              const task = pdfjsLib.renderTextLayer({
                textContentSource: textContent,
                container: textLayerDiv,
                viewport,
                textDivs: []
              });
              await (task.promise || task);
            } else if (window.pdfjsViewer && window.pdfjsViewer.TextLayerBuilder) {
              const eventBus = new window.pdfjsViewer.EventBus();
              const tlb = new window.pdfjsViewer.TextLayerBuilder({
                textLayerDiv,
                pageIndex: page.pageNumber - 1,
                viewport,
                eventBus,
              });
              tlb.setTextContent(textContent);
              await tlb.render();
            } else {
              await tryRenderTextLayer(page, viewport, textLayerDiv);
            }
          } catch (e) {
            // fallback path
            await tryRenderTextLayer(page, viewport, textLayerDiv);
          }
          if (viewerGen !== genAtStart) return;

          renderHighlightsForPage(pageDiv, num);

          renderedPages.add(num);
          observePage(pageDiv);

          window.parent.postMessage({ type: "PDF_PAGE_RENDERED", pageNumber: num }, "*");
        } catch (error) {
          console.error('Error rendering page', num, ':', error);

          const height = pageHeights.get(num) || estimatedPageHeight;
          const width = pageDiv.style.width || "100%";

          pageDiv.innerHTML = '';
          pageDiv.className = 'page-placeholder';
          pageDiv.style.width = width;
          pageDiv.style.height = height + "px";
          pageDiv.removeAttribute('data-rendered');

          renderedPages.delete(num);
        } finally {
          renderingPages.delete(num);
        }
      })();

      renderingPages.set(num, p);
      return p;
    }

    async function setupVirtualScroll(targetPage) {
      if (!pdfDoc) return;

      bumpViewerGen();
      clearViewer();

      const viewer = document.getElementById("viewer");

      const firstPage = await pdfDoc.getPage(1);
      const scale = computeScale(firstPage);
      const viewport = firstPage.getViewport({ scale });

      estimatedPageHeight = viewport.height;
      pageHeights.clear();
      pageHeights.set(1, viewport.height);

      setupPageObserver();

      for (let i = 1; i <= pdfDoc.numPages; i++) {
        const pageDiv = document.createElement("div");
        pageDiv.className = "page-placeholder";
        pageDiv.setAttribute("data-page-number", i);
        pageDiv.style.width = viewport.width + "px";
        pageDiv.style.height = estimatedPageHeight + "px";
        pageDiv.style.setProperty('--scale-factor', scale);
        viewer.appendChild(pageDiv);
        observePage(pageDiv);
      }

      if (!targetPage) {
        targetPage = pageNum;
      }

      const targetDiv = document.querySelector(`[data-page-number="${targetPage}"]`);
      if (targetDiv) {
        targetDiv.scrollIntoView({ behavior: 'auto', block: 'start' });
      }

      setCurrentPage(targetPage, true);

      await renderVisiblePages();
    }

    async function renderVisiblePages() {
      if (!pdfDoc) return;

      const { first, last } = getVisiblePageRange();
      const buffer = 2;

      const startPage = Math.max(1, first - buffer);
      const endPage = Math.min(pdfDoc.numPages, last + buffer);

      for (let i = startPage; i <= endPage; i++) {
        if (!renderedPages.has(i)) {
          const pageDiv = document.querySelector(`.page-placeholder[data-page-number="${i}"], .page[data-page-number="${i}"]`);
          if (pageDiv) {
            await renderPage(i, pageDiv);
          }
        }
      }

      cleanupOffscreenPages(startPage - 5, endPage + 5);
    }

    function cleanupOffscreenPages(keepStart, keepEnd) {
      const pagesToCleanup = [];

      renderedPages.forEach(pn => {
        if (pn < keepStart || pn > keepEnd) {
          pagesToCleanup.push(pn);
        }
      });

      pagesToCleanup.forEach(pn => {
        const pageDiv = document.querySelector(`.page[data-page-number="${pn}"]`);
        if (pageDiv && pageDiv.getAttribute('data-rendered') === 'true') {
          const height = pageHeights.get(pn) || estimatedPageHeight;
          const width = pageDiv.style.width;

          pageDiv.innerHTML = '';
          pageDiv.className = 'page-placeholder';
          pageDiv.style.width = width;
          pageDiv.style.height = height + "px";
          pageDiv.removeAttribute('data-rendered');

          renderedPages.delete(pn);
          observePage(pageDiv);
        }
      });
    }

    function goToPage(targetPage, instant = false) {
      if (!pdfDoc || targetPage < 1 || targetPage > pdfDoc.numPages) return;

      setCurrentPage(targetPage, false);

      const pageDiv = document.querySelector(`[data-page-number="${targetPage}"]`);
      if (pageDiv) {
        pageDiv.scrollIntoView({ behavior: instant ? 'auto' : 'smooth', block: 'start' });

        setTimeout(() => {
          renderVisiblePages();
        }, 100);
      }
    }

    let zoomRebuildTimer = null;
    let lastZoomAnchor = null;

    const container = document.getElementById('mainContainer');

    container.addEventListener('wheel', function(e) {
      if (e.ctrlKey) {
        e.preventDefault();

        const delta = -e.deltaY;
        const scaleFactor = delta > 0 ? 1.1 : 0.9;

        let newScale = fixedScale * scaleFactor;
        newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
        newScale = Math.round(newScale * 100) / 100;

        if (newScale === fixedScale) return;

        const containerRect = container.getBoundingClientRect();
        const mouseX = e.clientX - containerRect.left;
        const mouseY = e.clientY - containerRect.top;

        const denomW = Math.max(1, container.scrollWidth);
        const denomH = Math.max(1, container.scrollHeight);

        const pointX = (container.scrollLeft + mouseX) / denomW;
        const pointY = (container.scrollTop + mouseY) / denomH;

        fixedScale = newScale;
        zoomMode = "fixed";

        updateScaleSelect(fixedScale);
        showZoomIndicator(fixedScale);

        lastZoomAnchor = { mouseX, mouseY, pointX, pointY, savedPage: pageNum };

        if (zoomRebuildTimer) clearTimeout(zoomRebuildTimer);
        zoomRebuildTimer = setTimeout(() => {
          const anchor = lastZoomAnchor;
          if (!anchor) return;

          isNavigating = true;
          setupVirtualScroll(anchor.savedPage).then(() => {
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                // Giữ vị trí chuột ổn định theo hệ toạ độ scroll của container.
                const newScrollW = Math.max(1, container.scrollWidth);
                const newScrollH = Math.max(1, container.scrollHeight);

                const targetScrollX = anchor.pointX * newScrollW - anchor.mouseX;
                const targetScrollY = anchor.pointY * newScrollH - anchor.mouseY;

                const maxScrollX = Math.max(0, newScrollW - container.clientWidth);
                const maxScrollY = Math.max(0, newScrollH - container.clientHeight);

                container.scrollLeft = Math.max(0, Math.min(maxScrollX, targetScrollX));
                container.scrollTop = Math.max(0, Math.min(maxScrollY, targetScrollY));

                isNavigating = false;
                renderVisiblePages();
              });
            });
          });
        }, 120);
      }
    }, { passive: false });

    let isPanning = false;
    let startX = 0;
    let startY = 0;
    let scrollLeft = 0;
    let scrollTop = 0;

    document.addEventListener('keydown', function(e) {
      if (e.key === 'Shift' && !isPanning) {
        container.classList.add('can-pan');
      }
    });

    document.addEventListener('keyup', function(e) {
      if (e.key === 'Shift' && !isPanning) {
        container.classList.remove('can-pan');
      }
    });

    container.addEventListener('mousedown', function(e) {
      if (e.shiftKey || e.button === 1) {
        isPanning = true;
        startX = e.pageX - container.offsetLeft;
        startY = e.pageY - container.offsetTop;
        scrollLeft = container.scrollLeft;
        scrollTop = container.scrollTop;
        container.classList.add('is-panning');
        container.classList.remove('can-pan');
        e.preventDefault();
      }
    });

    container.addEventListener('mousemove', function(e) {
      if (!isPanning) return;
      e.preventDefault();

      const x = e.pageX - container.offsetLeft;
      const y = e.pageY - container.offsetTop;

      const walkX = (x - startX) * 1.5;
      const walkY = (y - startY) * 1.5;

      container.scrollLeft = scrollLeft - walkX;
      container.scrollTop = scrollTop - walkY;
    });

    const stopPanning = function(e) {
      if (isPanning) {
        isPanning = false;
        container.classList.remove('is-panning');
        if (e && e.shiftKey) {
          container.classList.add('can-pan');
        }
      }
    };

    container.addEventListener('mouseup', stopPanning);
    container.addEventListener('mouseleave', stopPanning);

    container.addEventListener('selectstart', function(e) {
      if (isPanning) {
        e.preventDefault();
      }
    });

    document.getElementById("previous").addEventListener("click", function () {
      if (!pdfDoc || pageNum <= 1) return;
      goToPage(pageNum - 1);
    });

    document.getElementById("next").addEventListener("click", function () {
      if (!pdfDoc || pageNum >= pdfDoc.numPages) return;
      goToPage(pageNum + 1);
    });

    document.getElementById("pageNumber").addEventListener("change", function () {
      const num = parseInt(this.value, 10);
      if (!isNaN(num)) {
        goToPage(num);
      }
    });

    document.getElementById("scaleSelect").addEventListener("change", function () {
      const v = this.value;
      if (v === "page-width") {
        zoomMode = "page-width";
      } else {
        const pct = parseInt(v, 10);
        if (!Number.isNaN(pct)) {
          zoomMode = "fixed";
          fixedScale = pct / 100;
        }
      }
      if (pdfDoc) {
        const savedPage = pageNum;
        setupVirtualScroll(savedPage).then(() => {
          setTimeout(() => {
            centerView();
          }, 100);
        });
      }
    });

    let renderScrollTimer = null;
    container.addEventListener('scroll', function() {
      if (renderScrollTimer) clearTimeout(renderScrollTimer);
      renderScrollTimer = setTimeout(() => {
        if (!isNavigating) {
          renderVisiblePages();
        }
      }, 150);
    }, { passive: true });

    window.addEventListener("message", function (event) {
      if (!event.data) return;

      if (event.data.type === "PDF_GO_TO_PAGE" && pdfDoc) {
        const num = parseInt(event.data.pageNumber, 10);
        if (!isNaN(num)) {
          goToPage(num);
        }
      }

      if (event.data.type === "PDF_OPEN_BYTES" && event.data.bytes) {
        pdfIdFromParent = event.data.pdfId || null;

        waitForPdfJs().then(function () {
          const uint8Array = new Uint8Array(event.data.bytes);
          pdfjsLib.getDocument({ data: uint8Array }).promise.then(function (doc) {
            pdfDoc = doc;

            const input = document.getElementById("pageNumber");
            input.max = String(pdfDoc.numPages);

            const pageCount = document.getElementById("pageCount");
            if (pageCount) pageCount.textContent = `/ ${pdfDoc.numPages}`;

            let startPage = 1;

            if (pdfIdFromParent) {
              try {
                const lastPage = parseInt(localStorage.getItem('pdf_last_page_' + pdfIdFromParent) || '1', 10);
                if (lastPage >= 1 && lastPage <= pdfDoc.numPages) {
                  startPage = lastPage;
                }
              } catch (e) {
                console.error('Failed to restore page:', e);
              }
            }

            setupVirtualScroll(startPage).then(() => {
              isNavigating = true;

              setTimeout(() => {
                centerView();

                setTimeout(() => {
                  isNavigating = false;
                  renderVisiblePages();
                }, 500);
              }, 100);
            });
          }).catch(err => {
            console.error('PDF load error:', err);
          });
        });
      }

      if (event.data.type === "PDF_SET_HIGHLIGHTS") {
        currentHighlights = event.data.highlights || [];

        renderedPages.forEach(pn => {
          const pageDiv = document.querySelector(`.page[data-page-number="${pn}"][data-rendered="true"]`);
          if (pageDiv) {
            renderHighlightsForPage(pageDiv, pn);
          }
        });
      }
    });

    document.addEventListener("mouseup", function () {
      if (selectionTimeout) return;

      selectionTimeout = setTimeout(() => {
        selectionTimeout = null;
      }, 150);

      const selection = window.getSelection();
      if (!selection) return;

      const text = selection.toString().trim();
      if (!text) return;

      try {
        if (selection.rangeCount === 0) return;

        const range = selection.getRangeAt(0);

        const commonAncestor = range.commonAncestorContainer;
        const pageDiv = commonAncestor.nodeType === 3
          ? commonAncestor.parentElement?.closest(".page")
          : commonAncestor.closest(".page");

        if (!pageDiv) return;

        const pageNumber = parseInt(pageDiv.getAttribute("data-page-number") || "0", 10);
        if (!pageNumber) return;

        const pageRect = pageDiv.getBoundingClientRect();
        if (pageRect.width === 0 || pageRect.height === 0) return;

        const rects = range.getClientRects();
        if (!rects || rects.length === 0) return;

        const pctRects = [];
        for (let i = 0; i < rects.length; i++) {
          const r = rects[i];

          const xPct = (r.left - pageRect.left) / pageRect.width;
          const yPct = (r.top - pageRect.top) / pageRect.height;
          const wPct = r.width / pageRect.width;
          const hPct = r.height / pageRect.height;

          if (wPct > 0 && hPct > 0 && xPct >= -0.01 && xPct <= 1.01) {
            pctRects.push({
              xPct: Math.max(0, Math.min(1, xPct)),
              yPct: Math.max(0, Math.min(1, yPct)),
              wPct,
              hPct
            });
          }
        }

        if (pctRects.length > 0) {
          let contextSentenceEn = '';

          // Prefer sentence extraction based on the exact clicked/ended position in the text layer.
          const textLayer = pageDiv.querySelector('.textLayer');
          const built = buildTextFromTextLayerAndGetIndex(textLayer, selection);
          if (built && built.text) {
            contextSentenceEn = extractContextSentenceAtIndex(built.text, built.index);
          }

          // Fallback: old behavior (first occurrence search in cached plain text)
          if (!contextSentenceEn) {
            const plainText = pagePlainTextByNumber.get(pageNumber) || '';
            contextSentenceEn = plainText ? extractContextSentence(plainText, text) : '';
          }

          window.parent.postMessage({
            type: "PDF_SELECTION",
            text,
            pageNumber,
            rects: pctRects,
            rectsPdf: pctRects,
            contextSentenceEn
          }, "*");
        }
      } catch (err) {
        console.error('Selection error:', err);
      }
    });

    window.parent.postMessage({ type: "PDF_VIEWER_READY" }, "*");
  </script>
</body>
</html>
