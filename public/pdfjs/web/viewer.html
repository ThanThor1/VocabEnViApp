<!DOCTYPE html>
<html dir="ltr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="google" content="notranslate">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>PDF Viewer</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.js"></script>

  <style>
    body { margin:0; padding:0; overflow:hidden; font-family:sans-serif; }
    #outerContainer { width:100%; height:100vh; position:absolute; display:flex; flex-direction:column; }
    #toolbarContainer { background:#f0f0f0; padding:10px; display:flex; gap:20px; border-bottom:1px solid #ccc; flex-wrap:wrap; }
    #mainContainer { flex:1; overflow:auto; background:#525659; display:flex; justify-content:center; padding:10px; }
    #viewer { background:transparent; }
    .page { background:white; position:relative; margin-bottom:15px; box-shadow:0 2px 8px rgba(0,0,0,0.3); }

    #toolbarLeft,#toolbarMiddle,#toolbarRight { display:flex; gap:10px; align-items:center; }
    .toolbarButton, select, input { padding:5px 10px; border:1px solid #ccc; border-radius:3px; cursor:pointer; font-size:14px; background:white; }
    .toolbarButton:hover { background:#e0e0e0; }
    input[type="number"] { width: 60px; }

    .textLayer {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      opacity: 0.2;
      line-height: 1.0;
      z-index: 2;
    }
    
    .textLayer > span {
      color: transparent;
      position: absolute;
      white-space: pre;
      cursor: text;
      transform-origin: 0% 0%;
    }
    
    .textLayer ::selection { 
      background: rgba(0,120,255,0.35); 
    }

    .vocab-highlight {
      z-index: 10;
      position: absolute;
      background-color: rgba(255,235,59,0.4);
      border: 1px solid rgba(251,192,45,0.6);
      cursor: pointer;
      transition: all 0.2s;
      pointer-events: auto;
    }
    
    .vocab-highlight:hover {
      background-color: rgba(255,213,79,0.5);
      border: 1px solid rgba(251,192,45,0.9);
      box-shadow: 0 0 8px rgba(251,192,45,0.5);
    }
    
    .vocab-tooltip {
      position: fixed;
      z-index: 9999;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      font-size: 13px;
      max-width: 250px;
      white-space: normal;
      word-wrap: break-word;
    }
    
    .tooltip-word {
      font-weight: bold;
      margin-bottom: 4px;
      color: #333;
    }
    
    .tooltip-meaning {
      color: #555;
      margin-bottom: 3px;
    }
    
    .tooltip-pronunciation {
      color: #888;
      font-size: 12px;
      font-style: italic;
    }

    #pageIndicator {
      position: fixed;
      right: 12px;
      bottom: 12px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 14px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 10000;
      pointer-events: none;
      font-family: monospace;
    }
    
    /* Page placeholder for virtual scrolling */
    .page-placeholder {
      background: #e0e0e0;
      position: relative;
      margin-bottom: 15px;
    }
  </style>
</head>

<body>
  <div id="outerContainer">
    <div id="toolbarContainer">
      <div id="toolbarLeft">
        <button id="previous" class="toolbarButton" title="Previous Page">◀</button>
        <input id="pageNumber" type="number" title="Page" value="1" min="1" />
        <span id="pageCount">/ 0</span>
        <button id="next" class="toolbarButton" title="Next Page">▶</button>
      </div>

      <div id="toolbarRight">
        <select id="scaleSelect" title="Zoom">
          <option value="auto">Auto</option>
          <option value="page-actual">100%</option>
          <option value="page-width">Fit Width</option>
          <option value="50">50%</option>
          <option value="75">75%</option>
          <option value="100">100%</option>
          <option value="125">125%</option>
          <option value="150" selected>150%</option>
          <option value="200">200%</option>
        </select>
      </div>
    </div>

    <div id="mainContainer">
      <div id="viewer"></div>
    </div>
  </div>

  <div id="pageIndicator">1 / 1</div>

  <script>
    let pdfjsLib = null;
    let pdfDoc = null;
    let pageNum = 1;
    let zoomMode = "fixed";
    let fixedScale = 1.5;
    let currentHighlights = [];
    let continuousScroll = true;
    let pdfIdFromParent = null;
    
    // Virtual scrolling state
    let renderedPages = new Set();
    let pageHeights = new Map();
    let estimatedPageHeight = 800;
    
    // Debounce/throttle timers
    let selectionTimeout = null;
    let pageUpdateTimer = null;
    let isNavigating = false; // Chỉ dùng cho restore từ localStorage
    
    // Intersection Observer for real-time page tracking
    let pageObserver = null;
    let visiblePages = new Map(); // Map<pageNum, visibilityRatio>

    function waitForPdfJs() {
      if (window.pdfjsLib) {
        pdfjsLib = window.pdfjsLib;
        pdfjsLib.GlobalWorkerOptions.workerSrc =
          "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
        return Promise.resolve();
      }
      return new Promise(resolve => setTimeout(() => waitForPdfJs().then(resolve), 100));
    }

    function updatePageIndicator() {
      const indicator = document.getElementById('pageIndicator');
      if (indicator && pdfDoc) {
        indicator.textContent = `${pageNum} / ${pdfDoc.numPages}`;
      }
    }

    function setCurrentPage(newPage, skipNotify) {
      if (!pdfDoc) return;
      
      const clamped = Math.max(1, Math.min(newPage, pdfDoc.numPages));
      if (clamped === pageNum) {
        updatePageIndicator();
        return;
      }

      pageNum = clamped;
      
      const input = document.getElementById('pageNumber');
      if (input) input.value = pageNum;
      
      updatePageIndicator();

      if (!skipNotify) {
        // Lưu localStorage ngay lập tức
        if (pdfIdFromParent) {
          try {
            localStorage.setItem('pdf_last_page_' + pdfIdFromParent, String(pageNum));
            console.log('Saved page:', pageNum);
          } catch (e) {
            console.error('Failed to save page:', e);
          }
        }
        
        // Debounce chỉ cho notify parent
        if (pageUpdateTimer) clearTimeout(pageUpdateTimer);
        
        pageUpdateTimer = setTimeout(() => {
          window.parent.postMessage({ 
            type: 'PDF_CURRENT_PAGE', 
            pageNumber: pageNum, 
            pdfId: pdfIdFromParent 
          }, '*');
        }, 200);
      }
    }

    // ===== INTERSECTION OBSERVER - REAL-TIME PAGE TRACKING =====
    
    function setupPageObserver() {
      // Cleanup observer cũ nếu có
      if (pageObserver) {
        pageObserver.disconnect();
      }
      
      // CRITICAL: Clear visible pages cache
      visiblePages.clear();
      
      const options = {
        root: document.getElementById('mainContainer'),
        rootMargin: '0px',
        threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0] // More granular tracking
      };
      
      pageObserver = new IntersectionObserver((entries) => {
        // Bỏ qua nếu đang navigate (CHỈ cho restore từ localStorage)
        if (isNavigating) return;
        
        entries.forEach(entry => {
          const entryPageNum = parseInt(entry.target.getAttribute('data-page-number'), 10);
          if (isNaN(entryPageNum)) return;
          
          if (entry.isIntersecting && entry.intersectionRatio > 0) {
            visiblePages.set(entryPageNum, entry.intersectionRatio);
          } else {
            visiblePages.delete(entryPageNum);
          }
        });
        
        // Tìm page có visibility cao nhất
        if (visiblePages.size > 0) {
          let bestPage = null;
          let bestRatio = 0;
          
          visiblePages.forEach((ratio, page) => {
            if (ratio > bestRatio) {
              bestRatio = ratio;
              bestPage = page;
            }
          });
          
          // Chỉ update nếu tìm được page tốt hơn và khác page hiện tại
          if (bestPage !== null && bestPage !== pageNum) {
            setCurrentPage(bestPage);
          }
        }
      }, options);
    }
    
    function observePage(pageDiv) {
      if (pageObserver && pageDiv) {
        pageObserver.observe(pageDiv);
      }
    }
    
    function unobservePage(pageDiv) {
      if (pageObserver && pageDiv) {
        pageObserver.unobserve(pageDiv);
      }
    }

    // ===== VIRTUAL SCROLLING - TÍNH TOÁN TRANG VISIBLE =====
    
    function getVisiblePageRange() {
      if (!pdfDoc) return { first: 1, last: 1 };

      const container = document.getElementById('mainContainer');
      if (!container) return { first: pageNum, last: pageNum };

      const scrollTop = container.scrollTop;
      const viewportHeight = container.clientHeight;
      
      let accumulatedHeight = 0;
      let firstVisible = 1;
      let lastVisible = 1;
      let foundFirst = false;

      for (let i = 1; i <= pdfDoc.numPages; i++) {
        const pageHeight = pageHeights.get(i) || estimatedPageHeight;
        
        if (!foundFirst && accumulatedHeight + pageHeight >= scrollTop) {
          firstVisible = i;
          foundFirst = true;
        }
        
        if (accumulatedHeight <= scrollTop + viewportHeight) {
          lastVisible = i;
        }
        
        accumulatedHeight += pageHeight + 15; // 15 = margin-bottom
        
        if (accumulatedHeight > scrollTop + viewportHeight) break;
      }

      return { 
        first: Math.max(1, firstVisible), 
        last: Math.min(pdfDoc.numPages, lastVisible) 
      };
    }

    function computeScale(page) {
      const base = page.getViewport({ scale: 1 });
      const container = document.getElementById("mainContainer");
      const cw = Math.max(100, (container ? container.clientWidth : window.innerWidth) - 24);
      const ch = Math.max(100, window.innerHeight - 130);

      if (zoomMode === "page-actual") return 1;
      if (zoomMode === "page-width" || zoomMode === "auto") return cw / base.width;
      if (zoomMode === "page-height") return ch / base.height;
      if (zoomMode === "page-fit") return Math.min(cw / base.width, ch / base.height);
      return fixedScale;
    }

    async function tryRenderTextLayer(page, viewport, textLayerDiv) {
      try {
        const textContent = await page.getTextContent();

        if (pdfjsLib && typeof pdfjsLib.renderTextLayer === "function") {
          const task = pdfjsLib.renderTextLayer({
            textContentSource: textContent,
            container: textLayerDiv,
            viewport,
            textDivs: []
          });
          await (task.promise || task);
          return true;
        }

        if (window.pdfjsViewer && window.pdfjsViewer.TextLayerBuilder) {
          const eventBus = new window.pdfjsViewer.EventBus();
          const tlb = new window.pdfjsViewer.TextLayerBuilder({
            textLayerDiv,
            pageIndex: page.pageNumber - 1,
            viewport,
            eventBus,
          });
          tlb.setTextContent(textContent);
          await tlb.render();
          return true;
        }

        return false;
      } catch (e) {
        console.warn("Text layer render failed:", e);
        return false;
      }
    }

    function renderHighlightsForPage(pageDiv, pageNumber) {
      // Chỉ render highlights cho pages đang visible
      const rect = pageDiv.getBoundingClientRect();
      if (rect.bottom < -100 || rect.top > window.innerHeight + 100) {
        return; // Skip offscreen pages
      }

      pageDiv.querySelectorAll(".vocab-highlight").forEach(el => el.remove());

      const list = currentHighlights.filter(h => h.pageNumber === pageNumber);

      list.forEach(hl => {
        (hl.rects || []).forEach(rect => {
          const d = document.createElement("div");
          d.className = "vocab-highlight";
          d.dataset.wordKey = hl.wordKey || "";
          d.dataset.word = hl.text || "";
          d.dataset.meaning = hl.meaning || "";
          d.dataset.pronunciation = hl.pronunciation || "";

          d.style.left = (rect.xPct * 100) + "%";
          d.style.top = (rect.yPct * 100) + "%";
          d.style.width = (rect.wPct * 100) + "%";
          d.style.height = (rect.hPct * 100) + "%";

          d.addEventListener("mouseenter", function () {
            document.querySelectorAll(".vocab-tooltip").forEach(el => el.remove());

            const word = this.dataset.word || this.dataset.wordKey || "";
            const meaning = this.dataset.meaning || "";
            const pronunciation = this.dataset.pronunciation || "";

            const tooltip = document.createElement("div");
            tooltip.className = "vocab-tooltip";
            tooltip.innerHTML = `
              ${word ? `<div class="tooltip-word">${word}</div>` : ""}
              ${meaning ? `<div class="tooltip-meaning">${meaning}</div>` : `<div class="tooltip-meaning">(chưa có nghĩa)</div>`}
              ${pronunciation ? `<div class="tooltip-pronunciation">${pronunciation}</div>` : ""}
            `;

            document.body.appendChild(tooltip);

            const targetRect = this.getBoundingClientRect();
            const tipRect = tooltip.getBoundingClientRect();

            let left = targetRect.left + targetRect.width / 2 - tipRect.width / 2;
            let top = targetRect.top - tipRect.height - 8;

            if (top < 6) {
              top = targetRect.bottom + 8;
            }

            left = Math.max(6, Math.min(left, window.innerWidth - tipRect.width - 6));

            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;

            this._tooltip = tooltip;
          });

          d.addEventListener("mouseleave", function () {
            if (this._tooltip) {
              this._tooltip.remove();
              this._tooltip = null;
            }
          });

          pageDiv.appendChild(d);
        });
      });
    }

    function clearViewer() {
      document.getElementById("viewer").innerHTML = "";
      renderedPages.clear();
      pageHeights.clear();
      visiblePages.clear();
    }

    // ===== RENDER PAGE WITH VIRTUAL SCROLLING =====
    
    async function renderPage(num, pageDiv) {
      if (!pdfDoc || num < 1 || num > pdfDoc.numPages) return;
      if (renderedPages.has(num)) return; // Already rendered

      try {
        const page = await pdfDoc.getPage(num);
        const scale = computeScale(page);
        const viewport = page.getViewport({ scale });

        // Update page div dimensions
        pageDiv.style.width = viewport.width + "px";
        pageDiv.style.height = viewport.height + "px";
        pageDiv.className = "page";
        pageDiv.setAttribute("data-page-number", num);
        pageDiv.setAttribute('data-rendered', 'true');
        
        // CRITICAL: Set scale-factor CSS variable for text layer alignment
        pageDiv.style.setProperty('--scale-factor', scale);
        
        // Store actual height
        pageHeights.set(num, viewport.height);

        const canvas = document.createElement("canvas");
        canvas.style.position = "absolute";
        canvas.style.left = "0";
        canvas.style.top = "0";
        canvas.style.zIndex = "1";
        canvas.style.width = viewport.width + "px";
        canvas.style.height = viewport.height + "px";

        const ctx = canvas.getContext("2d");

        const outputScale = window.devicePixelRatio || 1;
        canvas.width = Math.floor(viewport.width * outputScale);
        canvas.height = Math.floor(viewport.height * outputScale);

        const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;

        pageDiv.innerHTML = ''; // Clear placeholder content
        pageDiv.appendChild(canvas);

        const textLayerDiv = document.createElement("div");
        textLayerDiv.className = "textLayer";
        textLayerDiv.style.width = viewport.width + "px";
        textLayerDiv.style.height = viewport.height + "px";

        pageDiv.appendChild(textLayerDiv);

        await page.render({ canvasContext: ctx, viewport, transform }).promise;
        await tryRenderTextLayer(page, viewport, textLayerDiv);

        renderHighlightsForPage(pageDiv, num);
        
        renderedPages.add(num);
        
        // Re-observe page sau khi render (vì DOM đã thay đổi)
        observePage(pageDiv);

        window.parent.postMessage({ type: "PDF_PAGE_RENDERED", pageNumber: num }, "*");

      } catch (error) {
        console.error('Error rendering page', num, ':', error);
      }
    }

    // ===== VIRTUAL SCROLLING - SETUP PLACEHOLDERS =====
    
    async function setupVirtualScroll() {
      if (!pdfDoc) return;
      
      clearViewer();
      const viewer = document.getElementById("viewer");
      
      // Get first page to estimate dimensions
      const firstPage = await pdfDoc.getPage(1);
      const scale = computeScale(firstPage);
      const viewport = firstPage.getViewport({ scale });
      
      estimatedPageHeight = viewport.height;
      pageHeights.set(1, viewport.height);
      
      // Setup Intersection Observer
      setupPageObserver();
      
      // Create placeholder divs for all pages
      for (let i = 1; i <= pdfDoc.numPages; i++) {
        const pageDiv = document.createElement("div");
        pageDiv.className = "page-placeholder";
        pageDiv.setAttribute("data-page-number", i);
        pageDiv.style.width = viewport.width + "px";
        pageDiv.style.height = estimatedPageHeight + "px";
        pageDiv.style.setProperty('--scale-factor', scale);
        viewer.appendChild(pageDiv);
        
        // Observe page để track visibility
        observePage(pageDiv);
      }
      
      // Render initial visible pages
      await renderVisiblePages();
    }

    // ===== RENDER VISIBLE PAGES =====
    
    async function renderVisiblePages() {
      if (!pdfDoc) return;
      
      const { first, last } = getVisiblePageRange();
      const buffer = 2; // Render 2 pages ahead/behind
      
      const startPage = Math.max(1, first - buffer);
      const endPage = Math.min(pdfDoc.numPages, last + buffer);
      
      // Render visible + buffer pages
      for (let i = startPage; i <= endPage; i++) {
        if (!renderedPages.has(i)) {
          const pageDiv = document.querySelector(`.page-placeholder[data-page-number="${i}"], .page[data-page-number="${i}"]`);
          if (pageDiv) {
            await renderPage(i, pageDiv);
          }
        }
      }
      
      // Cleanup far offscreen pages to free memory
      cleanupOffscreenPages(startPage - 5, endPage + 5);
    }

    function cleanupOffscreenPages(keepStart, keepEnd) {
      const pagesToCleanup = [];
      
      renderedPages.forEach(pageNum => {
        if (pageNum < keepStart || pageNum > keepEnd) {
          pagesToCleanup.push(pageNum);
        }
      });
      
      pagesToCleanup.forEach(pageNum => {
        const pageDiv = document.querySelector(`.page[data-page-number="${pageNum}"]`);
        if (pageDiv && pageDiv.getAttribute('data-rendered') === 'true') {
          // Convert back to placeholder
          const height = pageHeights.get(pageNum) || estimatedPageHeight;
          const width = pageDiv.style.width;
          
          pageDiv.innerHTML = '';
          pageDiv.className = 'page-placeholder';
          pageDiv.style.width = width;
          pageDiv.style.height = height + "px";
          pageDiv.removeAttribute('data-rendered');
          
          renderedPages.delete(pageNum);
          
          // Re-observe placeholder
          observePage(pageDiv);
        }
      });
    }

    // ===== SIMPLE GO TO PAGE - KHÔNG dùng isNavigating flag =====
    
    function goToPage(targetPage, instant = false) {
      if (!pdfDoc || targetPage < 1 || targetPage > pdfDoc.numPages) return;
      
      // Update page number (không skip notify để trigger tracking)
      setCurrentPage(targetPage, false);
      
      const pageDiv = document.querySelector(`[data-page-number="${targetPage}"]`);
      if (pageDiv) {
        pageDiv.scrollIntoView({ behavior: instant ? 'auto' : 'smooth', block: 'start' });
        
        // Render visible pages ngay
        setTimeout(() => {
          renderVisiblePages();
        }, 100);
      }
    }

    // ===== EVENT LISTENERS =====
    
    document.getElementById("previous").addEventListener("click", function () {
      if (!pdfDoc || pageNum <= 1) return;
      goToPage(pageNum - 1);
    });

    document.getElementById("next").addEventListener("click", function () {
      if (!pdfDoc || pageNum >= pdfDoc.numPages) return;
      goToPage(pageNum + 1);
    });

    document.getElementById("pageNumber").addEventListener("change", function () {
      const num = parseInt(this.value, 10);
      if (!isNaN(num)) {
        goToPage(num);
      }
    });

    document.getElementById("scaleSelect").addEventListener("change", function () {
      const v = this.value;
      if (v === "auto" || v === "page-width") zoomMode = "page-width";
      else if (v === "page-actual" || v === "page-fit" || v === "page-height") zoomMode = v;
      else {
        const pct = parseInt(v, 10);
        if (!Number.isNaN(pct)) {
          zoomMode = "fixed";
          fixedScale = pct / 100;
        }
      }
      if (pdfDoc) {
        const savedPage = pageNum;
        setupVirtualScroll().then(() => {
          setTimeout(() => {
            goToPage(savedPage, true);
          }, 100);
        });
      }
    });

    // Chỉ dùng scroll handler cho renderVisiblePages
    let renderScrollTimer = null;
    document.getElementById('mainContainer').addEventListener('scroll', function() {
      if (renderScrollTimer) clearTimeout(renderScrollTimer);
      renderScrollTimer = setTimeout(() => {
        if (!isNavigating) {
          renderVisiblePages();
        }
      }, 150);
    }, { passive: true });

    // ===== MESSAGE HANDLERS =====
    
    window.addEventListener("message", function (event) {
      if (!event.data) return;

      if (event.data.type === "PDF_GO_TO_PAGE" && pdfDoc) {
        const num = parseInt(event.data.pageNumber, 10);
        if (!isNaN(num)) {
          goToPage(num);
        }
      }

      if (event.data.type === "PDF_OPEN_BYTES" && event.data.bytes) {
        pdfIdFromParent = event.data.pdfId || null;
        
        waitForPdfJs().then(function () {
          const uint8Array = new Uint8Array(event.data.bytes);
          pdfjsLib.getDocument({ data: uint8Array }).promise.then(function (doc) {
            pdfDoc = doc;
            
            const input = document.getElementById("pageNumber");
            input.max = String(pdfDoc.numPages);
            
            const pageCount = document.getElementById("pageCount");
            if (pageCount) pageCount.textContent = `/ ${pdfDoc.numPages}`;

            setCurrentPage(1, true);

            setupVirtualScroll().then(() => {
              // Khôi phục trang cuối cùng từ localStorage
              if (pdfIdFromParent) {
                try {
                  const lastPage = parseInt(localStorage.getItem('pdf_last_page_' + pdfIdFromParent) || '1', 10);
                  if (lastPage >= 1 && lastPage <= pdfDoc.numPages) {
                    // TẮT Intersection Observer và CLEAR cache CHỈ cho restore
                    isNavigating = true;
                    if (pageObserver) {
                      pageObserver.disconnect();
                    }
                    visiblePages.clear();
                    
                    setTimeout(() => {
                      // Scroll trực tiếp KHÔNG qua goToPage
                      const pageDiv = document.querySelector(`[data-page-number="${lastPage}"]`);
                      if (pageDiv) {
                        pageDiv.scrollIntoView({ behavior: 'auto', block: 'start' });
                      }
                      setCurrentPage(lastPage, true);
                      console.log('Restored to page:', lastPage);
                      
                      // BẬT LẠI Intersection Observer sau khi restore xong
                      setTimeout(() => {
                        setupPageObserver();
                        // Re-observe tất cả pages
                        document.querySelectorAll('.page, .page-placeholder').forEach(pageDiv => {
                          observePage(pageDiv);
                        });
                        isNavigating = false;
                        renderVisiblePages();
                      }, 800);
                    }, 500);
                  } else {
                    // Không có lastPage, bật observer ngay
                    isNavigating = false;
                  }
                } catch (e) {
                  console.error('Failed to restore page:', e);
                  isNavigating = false;
                }
              } else {
                isNavigating = false;
              }
            });
          }).catch(err => {
            console.error('PDF load error:', err);
          });
        });
      }

      if (event.data.type === "PDF_SET_HIGHLIGHTS") {
        currentHighlights = event.data.highlights || [];
        
        // Chỉ re-render highlights cho pages đã render
        renderedPages.forEach(pageNum => {
          const pageDiv = document.querySelector(`.page[data-page-number="${pageNum}"][data-rendered="true"]`);
          if (pageDiv) {
            renderHighlightsForPage(pageDiv, pageNum);
          }
        });
      }
    });

    // ===== TEXT SELECTION WITH THROTTLE =====
    
    document.addEventListener("mouseup", function () {
      // Throttle: ignore rapid selections
      if (selectionTimeout) return;
      
      selectionTimeout = setTimeout(() => {
        selectionTimeout = null;
      }, 150);
      
      const selection = window.getSelection();
      if (!selection) return;

      const text = selection.toString().trim();
      if (!text) return;

      try {
        if (selection.rangeCount === 0) return;

        const range = selection.getRangeAt(0);
        
        const commonAncestor = range.commonAncestorContainer;
        const pageDiv = commonAncestor.nodeType === 3
          ? commonAncestor.parentElement?.closest(".page")
          : commonAncestor.closest(".page");

        if (!pageDiv) return;

        const pageNumber = parseInt(pageDiv.getAttribute("data-page-number") || "0", 10);
        if (!pageNumber) return;

        const pageRect = pageDiv.getBoundingClientRect();
        if (pageRect.width === 0 || pageRect.height === 0) return;

        const rects = range.getClientRects();
        if (!rects || rects.length === 0) return;

        const pctRects = [];
        for (let i = 0; i < rects.length; i++) {
          const r = rects[i];
          
          const xPct = (r.left - pageRect.left) / pageRect.width;
          const yPct = (r.top - pageRect.top) / pageRect.height;
          const wPct = r.width / pageRect.width;
          const hPct = r.height / pageRect.height;
          
          if (wPct > 0 && hPct > 0 && xPct >= -0.01 && xPct <= 1.01) {
            pctRects.push({ 
              xPct: Math.max(0, Math.min(1, xPct)),
              yPct: Math.max(0, Math.min(1, yPct)),
              wPct,
              hPct 
            });
          }
        }

        if (pctRects.length > 0) {
          window.parent.postMessage({ 
            type: "PDF_SELECTION", 
            text, 
            pageNumber, 
            rects: pctRects 
          }, "*");
        }
      } catch (err) {
        console.error('Selection error:', err);
      }
    });

    window.parent.postMessage({ type: "PDF_VIEWER_READY" }, "*");
  </script>
</body>
</html>